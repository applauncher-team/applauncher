{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Applauncher","text":"<p>Applauncher is a tool that helps you to reuse your code by sharing all default functionalities among all of your projects. </p> <p>When you have several projects you realize that, in the beginning, you always write the same stuff (the database connection handlers, the configuration loader...). And it is very annoying. More than annoying, it is a problem because everytime you create a new project you need to spend time and the components are not exactly the same (due little customizations).</p> <p>In summary, if I usually use <code>mongodb</code> and <code>redis</code>, why not just create a thing that just  provides me that? It's like using <code>libraries</code>, but in this case we import <code>features</code>.</p> <p>This tool was developed with the following ideas in mind:</p> <ul> <li>Not intrusive: It does not tell you how to develop, but you should adapt your <code>main.py</code> (in the end applauncher is a launcher)</li> <li>Simple: Your applications are complex enough to add even more</li> <li>Fast: Applauncher should not steal your computing resources</li> <li>Tested: Applauncher is tested and relies on very tested libraries</li> <li>Community: Since many requirements are common (mysql, sentry...) any contribution can be enjoyed by anyone!</li> </ul> <p>Bundleszzzzzz</p>"},{"location":"anatomy/","title":"Anatomy","text":"<p>Applauncher tends to be as more simple as possible. These are the main elements that you need to Know</p>"},{"location":"anatomy/#bundle","title":"Bundle","text":"<p>A bundle is like a feature that <code>Applaucher</code> will offer to your application. For example, a functionality to get a <code>mongodb</code> working in your application will contain the configuration information, the way to create a mongo connection and how to provide this connection (usually by dependency injection). So you just import this bundle and from your code you just request a mongo connection. You dont have to handle the initialization, configuration, closing connections... You just write your code and <code>inject</code> all your dependencies.</p> <p>A bundle looks something like this:</p> <pre><code>from applauncher import Kernel, event\nfrom pydantic import BaseModel\nfrom dependency_injector import providers\n\nclass MysqlClient:\n    def __init__(self, port: int, hostname: str, database: str):\n        # This is a fake mysql cliente, but in should \n        # be an sqlalchmy connection or something like this\n        pass\n\n    def execute_query(self, query: str, params):\n        pass\n\nclass MysqlConfig(BaseModel):\n    port: int = 3306\n    hostname: str\n    database: str\n\nclass MysqlBundle:\n    def __init__(self):\n        # At this moment we are defining something like a bundle manifest\n\n        # The configuration required for this bundle\n        self.config_mapping = {\n            \"mysql\": MysqlConfig\n        }\n\n        # Subscribe to some events\n        self.event_listeners = [\n            (event.ConfigurationReadyEvent, self.configuration_ready)\n        ]\n\n    def configuration_ready(self, event):\n        config = event.configuration.mysql\n        # In config we have the model `MysqlConfig` but populated\n\n        # Here we define the dependency injection. We basically tell\n        # what classes will be available to be injected and\n        # the parameters needed by the container to instantiate it.\n        # This example is using the factory injection (a new \n        # instance will created on every injection) but there are \n        # more options like singleton (when you want to share\n        # the same instance) and more posibilites.\n        self.injection_bindings = {\n            MysqlClient: providers.Factory(\n                MysqlClient,\n                port=config.port,\n                hostname=config.hostname,\n                database=config.database\n            )\n        }\n\n        # In this example, a service does not make sense but it \n        # should only `provide` a mysql connection. But since \n        # this is an example, we will configure one. \n        # [45] is the args and {} the kwargs provided to your\n        # service function\n        self.services = [\n            (\"my_service\", self.service, [45], {\"foo\": \"bar\"})\n        ]\n\n    # This function will be executed in a separate process once\n    # the kernel is ready (configuration loaded, dependency\n    # container created...)\n    def service(self, value, foo):\n        from time import sleep\n        while True:\n            print(\"Value is\", 45, foo)\n            # Value is 45 bar\n            sleep(1)\n\n# Create the kernel providing the bundles (here only one, \n# but in a real application you use several bundles).\n# The line `kernel.wait()` will wait until all `services`\n# finishes and in case a signal (ctrl + c or kill) is\n# received, it will try to finish all services gracefully.\nwith Kernel(bundles=[MysqlBundle()], environment=\"PROD\") as kernel:\n    kernel.wait()\n</code></pre>"},{"location":"anatomy/#service","title":"Service","text":"<p>It is your code. It can be a web application, your program that processes files, a threaded application... whatever you want.</p>"},{"location":"anatomy/#configuration-mapping","title":"Configuration mapping","text":"<p>If your bundle requires configuration, you have to provide to the application this fields. This mapping contains for example the connection uri to your database. Applauncher will validate all these information and provides it to the bundle so we can trust this information.  The information can comes from a config file, environment variables... Your code does not really care, if just wants the values. The validation process relies on Pydantic so your validations will be very fast and powerful.</p>"},{"location":"anatomy/#events","title":"Events","text":"<p>Applauncher is event driven. You can raise events (information that is useful to other bundles) and subscribe to events (in case you want to get notified about something). For example, <code>kafka_bundle</code> will raise events on every message received so your application (and any other bundle) will subscribe to this event.</p>"},{"location":"anatomy/#dependency-injection","title":"Dependency injection","text":"<p>This is the mechanism used to provide and ask for services. Your bundle provide things (like a database connection) to be injected and other bundles (like your application) can inject them. The dependency injection feature relies on   Dependency Injector, check its documentation to see all amazing features.</p>"},{"location":"anatomy/#kernel","title":"Kernel","text":"<p>The kernel is just the thing that prepares the environment. Basically it loads the configuration and initialize the bundles and the very basic features (like the dependency injector container or the event system). The kernel also send <code>events</code> to notify these steps (when the configuarion is ready, when the application is fully loaded or when the bundles should shutdown because a sigterm was received). But there is nothing <code>smart</code> in this kernel, it will not take the control of your application or any unexpected thing at all. The hearth will always be your application.</p>"},{"location":"getting_started/","title":"Getting started","text":"<p>Applauncher tends to be as more simple as possible. These are the main elements that you need to Know</p>"},{"location":"getting_started/#bundle","title":"Bundle","text":"<p>A bundle is like a <code>functionality</code> that <code>Applaucher</code> will offer to your application. For example, a functionality to get a <code>mongodb</code> working in your application will contain the configuration information, the way to create a mongo connection and how to provide this connection (usually by dependency injection). So you just import this bundle and from your code you just request a mongo connection. You dont have to handle the initialization, configuration, closing connections... You just write your code and <code>inject</code> all your dependencies.</p>"},{"location":"getting_started/#service","title":"Service","text":"<p>It is your code. It can be a web application, your program that processes files, a threaded application... whatever you want.</p>"},{"location":"getting_started/#configuaration-mapping","title":"Configuaration mapping","text":""},{"location":"getting_started/#events","title":"Events","text":""},{"location":"kernel_lifecycle/","title":"Kernel lifecycle","text":"<p>There is a little lifecycle process since you run python until the application finishes, in order the events are: * ConfigurationReady * InjectorReady * KernelReady * KernelShutdown</p> <p>Your main application will run after the event <code>KernelReady</code></p>"},{"location":"kernel_lifecycle/#configurationreadyevent","title":"ConfigurationReadyEvent","text":"<p>This event will provide you the configuration parsed and validated. In case of any error, the information will be displayed specifying in a friendly way the errors to fix. Used when a <code>bundle</code> needs this to provide some service to <code>inject</code>, like a database connection.</p>"},{"location":"kernel_lifecycle/#injectorready","title":"InjectorReady","text":"<p>At this point everything is ready but until the application code can run, this event allows to do a last thing. This is useful when a bundle needs another bundle. It's not very common because <code>dependency injection</code> solves most of the cases but you sometimes you need it. We can think this event like a <code>pre run</code>.</p>"},{"location":"kernel_lifecycle/#kernelready","title":"KernelReady","text":"<p>At this point the application is fully started. Is when the services are started and here is when your code will start running. Here you can inject or do whatever you want</p>"},{"location":"kernel_lifecycle/#kernelshutdown","title":"KernelShutdown","text":"<p>When a <code>ctrl + c</code> or <code>sigterm</code> is received, the kernel will raise this event. The bundles subscribed to this event should prepare the shutdown process (close connection), and your service will receive the signal to start the shutdown process. By default, there will be grace time of 10 seconds. If any code is not able to be stopped in this grace time period, it will be killed. Anyway, resending the sigterm signal will kill the processes too.</p>"}]}